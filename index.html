<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Risk Scoring</title>
<style>
    :root {
        --bg: linear-gradient(120deg, rgba(30, 30, 30, 1) 0%, rgba(20, 20, 20, 1) 100%);
        --panel: rgba(255, 255, 255, 0.055);
        --panel-2: rgba(255, 255, 255, 0.038);
        --stroke: rgba(255, 255, 255, 0.12);
        --text: #ededf1;
        --muted: #a9adb7;

        --pink: #ec4899;
        --purple: #8b5cf6;
        --radius: 16px;
        --shadow: 0 12px 30px rgba(0, 0, 0, .38), inset 0 1px 0 rgba(255, 255, 255, .04);
    }

    * {
        box-sizing: border-box
    }

    html,
    body {
        height: 100%
    }

    body {
        margin: 0;
        color: var(--text);
        background: var(--bg);
        background-attachment: fixed;
        font-family: ui-sans-serif, system-ui, "Segoe UI", Roboto, Helvetica, Arial;
    }

    .wrap {
        max-width: 1100px;
        margin: 28px auto 56px;
        padding: 0 16px
    }

    header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px
    }

    h1 {
        font-size: clamp(20px, 4vw, 26px);
        margin: 0
    }

    .pill {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, .05);
        font-size: 12px
    }

    .card {
        background: var(--panel);
        border: 1px solid var(--stroke);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        backdrop-filter: blur(8px);
        margin-top: 16px
    }

    .card .head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 16px;
        border-bottom: 1px solid var(--stroke);
    }

    .overlayText {
        font-weight: 700;
        font-size: 13px;
        color: #fff;
        text-shadow: 0 2px 8px rgba(0, 0, 0, .45);
    }

    .card .body {
        padding: 16px
    }

    .controls {
        display: grid;
        gap: 10px;
        grid-template-columns: repeat(2, minmax(260px, 1fr))
    }

    @media (max-width:760px) {
        .controls {
            grid-template-columns: 1fr
        }
    }

    .row {
        background: var(--panel-2);
        border: 1px solid var(--stroke);
        border-radius: 14px;
        padding: 10px;
        display: grid;
        gap: 8px
    }

    .row label {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        font-size: 12px;
        color: var(--muted)
    }

    .select-wrap {
        position: relative
    }

    select {
        width: 100%;
        padding: 12px 40px 12px 12px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        font-size: 14px;
        font-weight: 600;
        color: var(--text);
        outline: none;
        appearance: none;
        -webkit-appearance: none;
        transition: background 0.25s ease, border-color 0.25s ease, color 0.25s ease;
        cursor: pointer;
    }

    select:not([data-color]),
    select[data-color="default"] {
        background: linear-gradient(180deg, rgba(255, 255, 255, .08), rgba(255, 255, 255, .03));
        border-color: var(--stroke);
        color: var(--text);
    }


    select[data-color="0"] {
        background: linear-gradient(180deg, rgba(255, 255, 255, .08), rgba(255, 255, 255, .03));
        border-color: var(--stroke);
        color: var(--text);
    }

    select[data-color="1"] {
        background: linear-gradient(180deg, rgba(139, 92, 246, .35), rgba(139, 92, 246, .15));
        border-color: rgba(139, 92, 246, .45);
        color: #dbeafe;
    }

    select[data-color="2"] {
        background: linear-gradient(180deg, rgba(16, 185, 129, .35), rgba(16, 185, 129, .15));
        border-color: rgba(16, 185, 129, .45);
        color: #d1fae5;
    }

    select[data-color="3"] {
        background: linear-gradient(180deg, rgba(234, 179, 8, .35), rgba(234, 179, 8, .15));
        border-color: rgba(234, 179, 8, .45);
        color: #fef9c3;
    }

    select[data-color="4"] {
        background: linear-gradient(180deg, rgba(251, 146, 60, .35), rgba(251, 146, 60, .15));
        border-color: rgba(251, 146, 60, .45);
        color: #fff7ed;
    }

    select[data-color="5"] {
        background: linear-gradient(180deg, rgba(239, 68, 68, .35), rgba(239, 68, 68, .15));
        border-color: rgba(239, 68, 68, .45);
        color: #fee2e2;
    }


    select option {
        background: #17181c;
        color: #f3f3f3
    }

    .select-wrap::after {
        content: "▾";
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        color: var(--muted);
        pointer-events: none;
        font-weight: 700
    }

    button {
        appearance: none;
        border: 1px solid var(--stroke);
        color: var(--text);
        background: linear-gradient(180deg, rgba(255, 255, 255, .09), rgba(255, 255, 255, .03));
        border-radius: 12px;
        padding: 9px 12px;
        cursor: pointer;
        font-weight: 600;
        transition: transform .1s ease, border-color .2s ease, background .2s ease
    }

    button:hover {
        transform: translateY(-1px);
        border-color: rgba(255, 255, 255, .24)
    }

    .ghost {
        background: transparent
    }


    .graph-wrap {
        position: relative;
        width: 100%;
        height: 360px
    }

    canvas#chart {
        width: 100%;
        height: 100%;
        display: block;
        filter: drop-shadow(0 12px 20px rgba(0, 0, 0, .45))
    }

    .overlayText {
        position: absolute;
        right: 12px;
        top: 15px;
        font-weight: 700;
        font-size: 13px;
        color: #fff;
        text-shadow: 0 2px 8px rgba(0, 0, 0, .45)
    }

    footer.site-footer {
        width: 100%;
        background: var(--panel);
        color: var(--muted);
        text-align: center;
        padding: 18px 0 14px 0;
        font-size: 13px;
        border-top: 1px solid var(--stroke);
        margin-top: 40px;
        box-shadow: 0 -2px 16px rgba(0, 0, 0, 0.08);
    }

    ul.list {
        margin: 6px 0 0 18px;
        padding: 0
    }

    ul.list li {
        margin: 6px 0
    }


    ::-webkit-scrollbar {
        width: 12px;
        height: 12px
    }

    ::-webkit-scrollbar-track {
        background: #121316;
        border-left: 1px solid rgba(255, 255, 255, .06)
    }

    ::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, rgba(139, 92, 246, .7), rgba(236, 72, 153, .7));
        border-radius: 999px;
        border: 2px solid #121316
    }

    ::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(180deg, rgba(139, 92, 246, .9), rgba(236, 72, 153, .9))
    }

    * {
        scrollbar-color: rgba(139, 92, 246, .8) #121316;
        scrollbar-width: thin
    }

    .fade {
        animation: fade .5s ease both
    }

    @keyframes fade {
        from {
            opacity: 0;
            transform: translateY(6px)
        }

        to {
            opacity: 1;
            transform: none
        }
    }

    .calc-table {
        overflow-x: auto;
    }

    .calc-table table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
    }

    .calc-table th,
    .calc-table td {
        padding: 6px 8px;
        border-bottom: 1px solid var(--stroke);
        text-align: left;
    }

    .calc-table th {
        color: var(--muted);
        font-weight: 600;
    }

    .calc-table td:last-child {
        text-align: right;
    }

    .calc-table th.sortable {
        cursor: pointer;
        user-select: none;
    }

    .calc-table th .arrow {
        margin-left: 6px;
        opacity: .7;
    }

    .calc-table th.sortable {
        position: relative;
        white-space: nowrap;
        cursor: pointer;
        user-select: none;
    }

    .calc-table th.sortable::after {
        content: '▲';
        display: inline-block;
        width: 1em;
        margin-left: 6px;
        opacity: .7;
        visibility: hidden;
    }

    .calc-table th.sortable[data-sort="asc"]::after {
        content: '▲';
        visibility: visible;
    }

    .calc-table th.sortable[data-sort="desc"]::after {
        content: '▼';
        visibility: visible;
    }

    #tooltip {
      position: fixed;
      z-index: 9999;
      max-width: 320px;
      background: rgba(17,17,20,.96);
      color: #e7e7ec;
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 10px 26px rgba(0,0,0,.45);
      font-size: 12px;
      line-height: 1.35;
      pointer-events: none;
      opacity: 0;
      transform: translate(-50%, -8px);
      transition: opacity .12s ease;
      white-space: normal;
    }

    #tooltip .t-k { 
      color: #a9adb7; 
    }

    #tooltip .t-v { 
      font-weight: 700; 
    }

</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Risk Scoring</h1>
      <div class="legend">
        <span class="pill">Score: <b id="scoreVal">0.00</b> / 5</span>
        <span class="pill">Window: <b id="windowVal">—</b></span>
        <span class="pill" id="decisionPill">Decision pending</span>
      </div>
    </header>

    <section class="card fade">
      <div class="head">
        <strong>Inputs</strong>
        <div>
            <button id="presetHi">High-risk example</button>
            <button id="presetLow">Low-risk example</button>
            <button id="presetRand">Random example</button>
            <button id="reset" class="ghost">Reset</button>
        </div>
      </div>
      <div class="body">
        <div id="controls" class="controls"></div>
      </div>
    </section>

    <section class="card fade">
        <div class="head">
          <strong>Calculation Details</strong>
          <div>
            <button id="exportCSV">Export CSV</button>
            <button id="exportJSON">Export JSON</button>
          </div>
        </div>
        <div class="body">
            <div id="calcDetails" class="calc-table"></div>
        </div>
    </section>

    <section class="card fade">
    <div class="head">
        <strong>Graph</strong>
        <div id="overlay" class="overlayText"></div>
    </div>
    <div class="body">
        <div class="graph-wrap">
        <canvas id="chart" width="1200" height="680" aria-label="Risk graph"></canvas>
        </div>
    </div>
    </section>

    <section class="card fade">
      <div class="head"><strong>Suggested Actions</strong></div>
      <div class="body">
        <ul id="suggestions" class="list"></ul>
      </div>
    </section>
  </div>


<script>

// DATA SECTION: Categories define each scoring dimension.
// Each object has:
//   key:   unique identifier (used in state, controls, exports, etc.)
//   w:     raw weight (%) contribution toward the overall score
//   label: human readable name shown in the UI
//   help:  { what: short description of what this input measures,
//            ex:   example values / guidance for selecting 0–5 }
// 
// Notes:
// - Values are scored on a 0–5 scale. Higher means greater risk, unless
//   the category is compensating/mitigating (where low may be worse).
// - Weights should sum to ~100 so that the weightedScore stays in the 0–5 range.
// - Update THRESHOLDS if you adjust weights significantly or change the scoring scale.
// - Tooltips, aria labels, exports, and suggestions should be able to pull directly from help.
// - To add a new category, add an object with the same structure.
//   Example:
//     { key:'newcat', w:4, label:'New Category Placeholder',
//       help:{ what:'Brief description', ex:'Example: 0 = none, 5 = severe' } }
const CATEGORIES = [
  {key:'cvss', w:10, label:'CVSS Severity',
   help:{ what:'Base severity of the vulnerability (CVSS v3.x/4).',
          ex:'e.g., CVSS 9.8 -> 5; CVSS 4.0 -> 2' }},

  {key:'explAvail', w:10, label:'Exploit Availability',
   help:{ what:'Whether reliable exploit code exists/is circulating.',
          ex:'Public PoC/Metasploit -> 4–5; none known -> 0–1' }},

  {key:'activeWild', w:10, label:'Actively Exploited',
   help:{ what:'Evidence of in-the-wild exploitation (e.g., CISA KEV).',
          ex:'On KEV / confirmed incidents -> 5' }},

  {key:'vector', w:5, label:'Exploitation Vector',
   help:{ what:'How the vuln can be reached.',
          ex:'Network -> 5; Adjacent -> 3; Local/Physical -> 1–0' }},

  {key:'human', w:5, label:'Human Interaction',
   help:{ what:'User action required to exploit?',
          ex:'No user action -> 4–5; needs convincing click -> 1–2' }},

  {key:'criticality', w:10, label:'Server Criticality',
   help:{ what:'Business/system criticality of the affected asset.',
          ex:'Payments/PII/production core -> 4–5; lab/dev -> 1–2' }},

  {key:'internet', w:10, label:'Internet Exposure',
   help:{ what:'Externally reachable from the internet?',
          ex:'Public API/portal -> 4–5; internal only -> 0–1' }},

  {key:'apt', w:5, label:'APT Association',
   help:{ what:'Linked to known targeted/APT actor TTPs.',
          ex:'Actor actively using this vuln -> 4–5' }},

  {key:'ctrls', w:5, label:'Compensating Controls',
   help:{ what:'Strength of mitigations reducing exploitability/impact.',
          ex:'Strong MFA/WAF/segmentation -> 4–5; weak/none -> 0–1' }},

  {key:'env', w:5, label:'Environment Tier',
   help:{ what:'Sensitivity/tier of the environment.',
          ex:'Prod with customer data -> 4–5; test/sandbox -> 1–2' }},

  {key:'intel', w:5, label:'Threat Intel Priority',
   help:{ what:'Current intel pressure (chatter/IOCs targeting you).',
          ex:'Active chatter/IOCs -> 4–5; quiet -> 0–1' }},

  {key:'time', w:3, label:'Time Since Disclosure',
   help:{ what:'How long it’s been publicly known.',
          ex:'Old & unpatched (months) -> 3–5; very new -> 0–1' }},

  {key:'patchable', w:3, label:'Patch Achievability',
   help:{ what:'How feasible it is to patch quickly.',
          ex:'No patch/major downtime -> 0–1; easy patch -> 4–5' }},

  {key:'chain', w:3, label:'Chaining Potential',
   help:{ what:'How well this combines with other vulns to escalate.',
          ex:'Common privilege-esc chain -> 4–5' }},

  {key:'epss', w:3, label:'Exploit Prediction Scoring',
   help:{ what:'EPSS-like likelihood proxy of exploitation.',
          ex:'Top percentile -> 4–5; very low -> 0–1' }},

  {key:'geo', w:2, label:'Geo Specific Relevance',
   help:{ what:'Targeting relevance for your region/sector.',
          ex:'You’re in the active targeting region -> 3–5' }},

  {key:'impact', w:3, label:'User/Customer Impact',
   help:{ what:'Blast radius to customers/users if exploited.',
          ex:'Data exfil/service outage -> 4–5; negligible -> 0–1' }},

  {key:'sla', w:3, label:'SLA Impact',
   help:{ what:'Regulatory/contractual/SLA implications.',
          ex:'Penalties/obligations triggered -> 4–5' }},
  // {key:'newcat', w:4, label:'New Category Placeholder', help:{ what:'...', ex:'...' }},
];






// THRESHOLDS: Customize patch windows and labels as needed.
// Each object sets the minimum score and the corresponding patch window label.
// You can add, remove, or change these for more specific guidance (e.g., add more granular windows, change timeframes, or use custom labels).
// IMPORTANT: Keep thresholds sorted descending by min, e.g. [{min:4.5}, {min:3.8}, ... , {min:-Infinity}]
// If weights don't sum to ~100, consider clamping the score before calling decisionFor.
// Example:
// {min:4.5, label:'Patch in 3 days'},
// {min:3.8, label:'Patch in 7 days'},
// ...
const THRESHOLDS = [
  {min:3.8, label:'Patch in 7 days'},
  {min:3.0, label:'Patch in 14 days'},
  {min:2.0, label:'Patch in 21 days'},
  {min:-Infinity, label:'Patch in 60 days'},
];




function totalRawWeight() {
  return CATEGORIES.reduce((a, c) => a + (Number(c.w) || 0), 0) || 1;
}

function getEffectiveWeightMap() {
  const tw = totalRawWeight();
  return Object.fromEntries(CATEGORIES.map(c => [c.key, (Number(c.w) || 0) / tw]));
}


const state = Object.fromEntries(CATEGORIES.map(c=>[c.key,0]));

function updateSelectColor(sel, val) {
  sel.dataset.color = String(val);
}


const controls = document.getElementById('controls');

const tipEl = document.getElementById('tooltip');
function showTip(html, x, y){
  if (!tipEl) return;
  tipEl.innerHTML = html;
  tipEl.style.left = `${x}px`;
  tipEl.style.top  = `${y-12}px`;
  tipEl.style.opacity = '1';
  tipEl.setAttribute('aria-hidden','false');
}
function moveTip(x,y){ if (!tipEl) return;
  tipEl.style.left = `${x}px`;
  tipEl.style.top  = `${y-12}px`;
}
function hideTip(){ if (!tipEl) return;
  tipEl.style.opacity='0';
  tipEl.setAttribute('aria-hidden','true');
}

function buildSelect(id){
  const wrap = document.createElement('div'); wrap.className='select-wrap';
  const sel = document.createElement('select'); sel.id=id; sel.setAttribute('aria-label', id);
  sel.dataset.color = "default";

  for(let i=0;i<=5;i++){ 
    const o=document.createElement('option'); 
    o.value=i; 
    o.textContent=i; 
    sel.appendChild(o); 
  }

  sel.addEventListener('input',()=>{
    state[id] = Number(sel.value);
    updateSelectColor(sel, state[id]);
    scheduleAll();
  });

  wrap.appendChild(sel); 
  return wrap;
}

CATEGORIES.forEach(c=>{
  const row = document.createElement('div'); row.className='row';

  const lbl = document.createElement('label');
  lbl.htmlFor = c.key;
  lbl.innerHTML = `<span>${c.label}</span><span>${c.w}%</span>`;

  const wrap = buildSelect(c.key);
  const sel  = wrap.querySelector('select');

  const titleText = c.help ? `${c.help.what}  Example: ${c.help.ex}` : c.label;
  sel.setAttribute('aria-label', `${c.label}. ${titleText}`);
  sel.title = titleText;

  const tipHTML = c.help
    ? `<div><span class="t-k">What:</span> ${c.help.what}</div>
       <div><span class="t-k">Example:</span> <span class="t-v">${c.help.ex}</span></div>`
    : `<div>${c.label}</div>`;

  [row, wrap].forEach(el=>{
    el.addEventListener('mouseenter', e => showTip(tipHTML, e.clientX, e.clientY));
    el.addEventListener('mousemove',  e => moveTip(e.clientX,  e.clientY));
    el.addEventListener('mouseleave', hideTip, {passive:true});
  });

  row.append(lbl, wrap);
  controls.appendChild(row);
});

const scoreEl = document.getElementById('scoreVal');
const windowEl = document.getElementById('windowVal');
const pill = document.getElementById('decisionPill');
const suggEl = document.getElementById('suggestions');
const overlay = document.getElementById('overlay');

function weightedScore(){
  const eff = getEffectiveWeightMap();
  return CATEGORIES.reduce((acc, c) => acc + eff[c.key] * state[c.key], 0);
}

function decisionFor(score){ return THRESHOLDS.find(t=> score >= t.min).label }
function setPill(text, score) {
  const s = Math.min(Math.max(score, 0), 5);
  let hue;
  if (s <= 2.5) {
    hue = 280 - (s / 2.5) * (280 - 30);
  } else {
    hue = 30 - ((s - 2.5) / 2.5) * 30;
  }
  pill.textContent = text;
  pill.style.borderColor = `hsla(${hue}, 90%, 60%, .45)`;
  pill.style.boxShadow   = `0 0 0 1px hsla(${hue}, 90%, 60%, .28) inset`;
}

// SUGGESTION_RULES: Customize suggestions and their conditions as needed.
// There are two types of suggestion rules:
//
// 1. Global rules (no 'for' property):
//    - Apply to the overall state and score.
//    - Format: { text: "...", condition: (state, score, ctx) => ... }
//    - ctx contains: eff (effective weights), contrib (contribution map)
//
// 2. Category-scoped rules (with 'for' property):
//    - Apply to specific categories (single key or array of keys).
//    - Format: { for: 'key' | ['key1','key2'], text: "..." | (ctx) => ..., condition: (state, score, ctx) => ... }
//    - ctx contains: score, eff, contrib, key, label, value (0..5)
//    - If text is a function, it receives ctx for dynamic output.
//
// Values are integers 0–5. Using <= 0.5 triggers only at 0; use <= 1 for "low". Exact equality (===) is strict; use >= for ranges if needed.
// Example global:
//   { text: "Custom suggestion text.", condition: (state) => state.newcat >= 3 }
// Example category-scoped:
//   { for: 'cvss', text: ctx => `High ${ctx.label}: ...`, condition: (state, score, ctx) => ctx.value >= 4 }
const SUGGESTION_RULES = [
  {
    text: "CISA KEV: treat as emergency; patch/mitigate immediately, add detections, monitor IOCs.",
    condition: (state) => state.activeWild >= 5
  },
  {
    text: "Internet-exposed: put behind WAF/reverse proxy, enforce allowlists, rate-limit endpoints.",
    condition: (state) => state.internet >= 4
  },
  {
    text: "Public exploit: accelerate patching; deploy virtual patching (WAF/IPS); tighten logging.",
    condition: (state) => state.explAvail >= 4
  },
  {
    text: "Network-reachable: restrict ingress ports and segment access.",
    condition: (state) => state.vector === 5
  },
  {
    text: "Add MFA, WAF/IPS rules, least-privilege and monitoring to compensate.",
    condition: (state) => state.ctrls <= 0.5
  },
  {
    text: "High-criticality: schedule immediate maintenance window and prepare rollback.",
    condition: (state) => state.criticality >= 4
  },
  {
    text: "Patch unavailable: apply vendor mitigations, disable vulnerable features, sandbox, isolate.",
    condition: (state) => state.patchable <= 0.5
  },


  // Example A: Only when Internet exposure is high AND total score is high
  {
    for: 'internet',
    text: (ctx) => `High ${ctx.label}: enforce WAF rules, rate limits, and geo/IP allowlists.`,
    condition: (state, score, ctx) => ctx.value >= 4 && score >= 3.5
  },

  // Example B: If a category’s contribution is big (it’s carrying the score)
  {
    for: ['cvss','explAvail','activeWild'],
    text: (ctx) => `${ctx.label} is driving risk (≈${ctx.contrib.toFixed(2)} pts): prioritize fixes/mitigations here.`,
    condition: (state, score, ctx) => ctx.contrib >= 1.2 // ~24% of total if score ~5
  },

  // Example C: Category low but weight high -->> suggest compensating control
  {
    for: 'ctrls',
    text: 'Weak compensating controls: tighten MFA, RBAC, and add targeted detections.',
    condition: (state, score, ctx) => ctx.value <= 1 && ctx.eff[ctx.key] >= 0.08 // ≥8% effective weight
  }
];



const DEFAULT_SUGGESTION =
  "Patch per window; keep monitoring EPSS/KEV; enhance logs/alerts.";


function suggestions() {
  const score = weightedScore();
  const eff = getEffectiveWeightMap();
  const contrib = Object.fromEntries(
    CATEGORIES.map(c => [c.key, eff[c.key] * state[c.key]])
  );
  const labelByKey = Object.fromEntries(CATEGORIES.map(c => [c.key, c.label]));

  const out = [];

  for (const rule of SUGGESTION_RULES) {
    if (!rule.for) {
      if (rule.condition?.(state, score, { eff, contrib })) {
        out.push(typeof rule.text === 'function' ? rule.text({ score }) : rule.text);
      }
      continue;
    }

    // category scoped rule: rule.for can be 'cvss' or ['cvss','internet']
    const keys = Array.isArray(rule.for) ? rule.for : [rule.for];
    for (const k of keys) {
      if (!state.hasOwnProperty(k)) continue;
      const ctx = { 
        score, 
        eff, 
        contrib, 
        key: k, 
        label: labelByKey[k], 
        value: state[k]
      };
      if (rule.condition?.(state, score, ctx)) {
        const text = typeof rule.text === 'function' 
          ? rule.text(ctx) 
          : (rule.text || '').replace(/\{cat\}/g, ctx.label);
        out.push(text);
      }
    }
  }

  if (out.length === 0) out.push(DEFAULT_SUGGESTION);
  return out.slice(0, 6);
}

const canvas = document.getElementById('chart');
const ctx = canvas.getContext('2d');
let dpi = 1;

function resizeCanvas(){
  const r = canvas.getBoundingClientRect();
  dpi = window.devicePixelRatio || 1;
  canvas.width = Math.round(r.width * dpi);
  canvas.height = Math.round(r.height * dpi);
  ctx.setTransform(dpi,0,0,dpi,0,0);
}
window.addEventListener('resize', resizeCanvas,{passive:true}); resizeCanvas();

function makeTargets(){
  const vals = CATEGORIES.map(c => state[c.key] / 5);
  const total = Math.min(Math.max(weightedScore(),0),5)/5;
  vals.push(total);
  return vals;
}

const calcDetails = document.getElementById('calcDetails');

let calcSort = { key: 'label', dir: 'asc' };

function sortRows(rows, key, dir){
  const mult = dir === 'asc' ? 1 : -1;
  return rows.sort((a,b)=>{
    const va = a[key], vb = b[key];
    if (typeof va === 'string' || typeof vb === 'string') {
      return mult * String(va).localeCompare(String(vb), undefined, {sensitivity:'base'});
    }
    return mult * (va - vb);
  });
}

function updateCalcTable() {
  const eff = getEffectiveWeightMap();
  const rows = CATEGORIES.map(c => {
    const val = state[c.key];
    const effFrac = eff[c.key];
    const effPct = effFrac * 100;
    const contribPts = effFrac * val;
    return {
      label: c.label,
      w_raw: Number(c.w) || 0,
      w_eff_pct: Number(effPct.toFixed(2)),
      val,
      contrib: Number(contribPts.toFixed(2))
    };
  });

  const keyMap = { w: 'w_eff_pct', label: 'label', val: 'val', contrib: 'contrib' };
  const sortKey = keyMap[calcSort.key] || 'label';
  const mult = calcSort.dir === 'asc' ? 1 : -1;
  rows.sort((a, b) => {
    const va = a[sortKey], vb = b[sortKey];
    if (typeof va === 'string' || typeof vb === 'string') {
      return mult * String(va).localeCompare(String(vb), undefined, { sensitivity: 'base' });
    }
    return mult * (va - vb);
  });

  const headHTML = `
    <thead><tr>
      <th class="sortable" data-key="label"   data-sort="${calcSort.key==='label'  ? calcSort.dir : 'none'}">Category</th>
      <th                                   >Raw Weight %</th>
      <th class="sortable" data-key="w"       data-sort="${calcSort.key==='w'      ? calcSort.dir : 'none'}">Effective Weight %</th>
      <th class="sortable" data-key="val"     data-sort="${calcSort.key==='val'    ? calcSort.dir : 'none'}">Value (0–5)</th>
      <th class="sortable" data-key="contrib" data-sort="${calcSort.key==='contrib'? calcSort.dir : 'none'}">Contribution (pts)</th>
    </tr></thead>`;

  const bodyHTML = rows.map(r => `
    <tr>
      <td>${r.label}</td>
      <td>${r.w_raw}%</td>
      <td>${r.w_eff_pct.toFixed(2)}%</td>
      <td>${r.val}</td>
      <td>${r.contrib.toFixed(2)}</td>
    </tr>`).join('');

  calcDetails.innerHTML = `<table>${headHTML}<tbody>${bodyHTML}</tbody></table>`;
  bindCalcSortHandlers();
}

function bindCalcSortHandlers(){
  const ths = calcDetails.querySelectorAll('th.sortable');
  ths.forEach(th=>{
    th.onclick = () => {
      const key = th.getAttribute('data-key');
      if (calcSort.key === key){
        calcSort.dir = (calcSort.dir === 'asc') ? 'desc' : 'asc';
      } else {
        calcSort.key = key;
        calcSort.dir = 'asc';
      }
      updateCalcTable();
    };
  });
}


let target = makeTargets();
let current = target.map(v=>0);
let rippleAmp = 0;
let phase = 0;
function scheduleUpdate(){ target = makeTargets(); rippleAmp = 18; }

function lerp(a,b,t){ return a+(b-a)*t }
function clamp(n,min,max){ return Math.max(min,Math.min(max,n)) }
function grid(w,h){
  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,0.07)';
  ctx.lineWidth=1;
  const stepX = Math.round(w/12), stepY = Math.round(h/6);
  for(let x=0;x<=w;x+=stepX){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke() }
  for(let y=0;y<=h;y+=stepY){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke() }
  ctx.restore();
}

function draw(){
  const w = canvas.width / dpi, h = canvas.height / dpi;
  ctx.clearRect(0,0,w,h);
  grid(w,h);

  for(let i=0;i<current.length;i++) current[i] = lerp(current[i], target[i], 0.09);

  const leftPad = 24, rightPad = 24, topPad = 18, botPad = 28;
  const innerW = w - leftPad - rightPad, innerH = h - topPad - botPad;

  const n = current.length;
  const pts = [];
  for(let i=0;i<n;i++){
    const t = (n===1?0:i/(n-1));
    const x = leftPad + t*innerW;
    let yNorm = 1 - current[i];
    const ripple = Math.sin((t*8* Math.PI) - phase) * (rippleAmp/innerH);
    yNorm = clamp(yNorm + ripple, 0, 1);
    const y = topPad + yNorm * innerH;
    pts.push({x,y});
  }
  rippleAmp *= 0.92;
  phase += 0.12 + (Math.min(Math.max(weightedScore(),0),5)/5)*0.04;

  ctx.save();
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for(const p of pts) ctx.lineTo(p.x,p.y);
  ctx.lineTo(leftPad + innerW, topPad + innerH);
  ctx.lineTo(leftPad,            topPad + innerH);
  ctx.closePath();
  const grad = ctx.createLinearGradient(0, topPad, 0, topPad+innerH);
  grad.addColorStop(0,   "rgba(139,92,246,0.35)");
  grad.addColorStop(0.55,"rgba(236,72,153,0.22)");
  grad.addColorStop(1,   "rgba(0,0,0,0.0)");
  ctx.fillStyle = grad;
  ctx.fill();
  ctx.restore();

  const g2 = ctx.createLinearGradient(leftPad,0,leftPad+innerW,0);
  g2.addColorStop(0,"rgba(139,92,246,0.95)");
  g2.addColorStop(1,"rgba(236,72,153,0.95)");
  ctx.lineWidth = 3;
  ctx.strokeStyle = g2;
  ctx.shadowColor="rgba(0,0,0,.5)"; ctx.shadowBlur=6;
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for(const p of pts) ctx.lineTo(p.x,p.y);
  ctx.stroke();
  ctx.shadowBlur=0;

  ctx.fillStyle = "#131318"; ctx.strokeStyle="#fff"; ctx.lineWidth=1.8;
  for(const [i,p] of pts.entries()){
    ctx.beginPath(); ctx.arc(p.x, p.y, 4.2, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    if (w>680){
      ctx.fillStyle='rgba(255,255,255,.55)'; ctx.font='11px ui-sans-serif,system-ui';
      const label = (i<n-1) ? String(i+1).padStart(2,'0') : 'Total';
      ctx.textAlign='center'; ctx.fillText(label, p.x, topPad+innerH+16);
      ctx.fillStyle="#131318";
    }
  }

  requestAnimationFrame(draw);
}
draw();


function computeCalcRows() {
  const eff = getEffectiveWeightMap();
  return CATEGORIES.map(c => {
    const val = state[c.key];
    const effFrac = eff[c.key];
    const effPct = effFrac * 100;
    const contribPts = effFrac * val;
    return {
      key: c.key,
      label: c.label,
      w_raw: Number(c.w) || 0,
      w_eff_pct: Number(effPct.toFixed(2)),
      val,
      contrib: Number(contribPts.toFixed(2))
    };
  });
}

function buildExportPayload() {
  const score = Number(weightedScore().toFixed(2));
  return {
    generatedAt: new Date().toISOString(),
    overall: { score, window: decisionFor(score) },
    inputs: Object.fromEntries(CATEGORIES.map(c => [c.key, state[c.key]])),
    categories: computeCalcRows(),
    suggestions: suggestions()
  };
}

function download(filename, mime, data) {
  const blob = new Blob([data], { type: mime });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    URL.revokeObjectURL(a.href);
    a.remove();
  }, 0);
}

function exportJSON() {
  const payload = buildExportPayload();
  download(`risk-report-${Date.now()}.json`, 'application/json', JSON.stringify(payload, null, 2));
}

function toCSV(rows) {
  const headers = ['Category', 'Raw Weight %', 'Effective Weight %', 'Value', 'Contribution (pts)'];
  const lines = [headers.join(',')];
  for (const r of rows) {
    lines.push(
      [r.label, r.w_raw, r.w_eff_pct, r.val, r.contrib]
        .map(v => `"${String(v).replace(/"/g, '""')}"`)
        .join(',')
    );
  }
  return lines.join('\n');
}

function exportCSV() {
  const score = Number(weightedScore().toFixed(2));
  const rows = computeCalcRows();

  const keyMap = { w: 'w_eff_pct', label: 'label', val: 'val', contrib: 'contrib' };
  const sortKey = keyMap[calcSort.key] || 'label';
  const mult = calcSort.dir === 'asc' ? 1 : -1;
  rows.sort((a, b) => {
    const va = a[sortKey], vb = b[sortKey];
    if (typeof va === 'string' || typeof vb === 'string') {
      return mult * String(va).localeCompare(String(vb), undefined, { sensitivity: 'base' });
    }
    return mult * (va - vb);
  });

  const preface = [
    `Generated At,${new Date().toISOString()}`,
    `Overall Score,${score}`,
    `Patch Window,${decisionFor(score)}`,
    ''
  ].join('\n');

  const csvBody = toCSV(rows);
  const sugg = suggestions().map(s => `- ${s}`).join('\n');
  const csv = `${preface}${csvBody}\n\nSuggestions\n${sugg}`;

  download(`risk-report-${Date.now()}.csv`, 'text/csv', csv);
}



function updateOutputs(){
  const score = weightedScore();
  scoreEl.textContent = score.toFixed(2);
  const dec = decisionFor(score);
  windowEl.textContent = dec;
  setPill(dec, score);
  overlay.textContent = `Score ${score.toFixed(2)} • ${dec}`;

  const list = suggestions();
  suggEl.innerHTML = '';
  list.forEach(t=>{ const li=document.createElement('li'); li.textContent=t; suggEl.appendChild(li) });
  updateCalcTable();
}
function scheduleAll(){ scheduleUpdate(); updateOutputs(); }





function applyPreset(getValue) {
  CATEGORIES.forEach(cat => {
    const val = Math.max(0, Math.min(5, Math.round(getValue(cat))));
    state[cat.key] = val;
    const sel = document.getElementById(cat.key);
    if (sel) {
      sel.value = val;
      updateSelectColor(sel, val);
    }
  });
  scheduleAll();
}

const PRESETS = {
  high: {
    fallback: () => 5,
    overrides: { apt: 4, intel: 4, geo: 3, sla: 4 }
  },
  low: {
    fallback: () => 0,
    overrides: {
      cvss: 1, vector: 1, human: 1, criticality: 1,
      ctrls: 2, env: 1, intel: 1, patchable: 2,
      impact: 1, sla: 1
    }
  }
};

function runPreset(name) {
  const p = PRESETS[name];
  applyPreset(cat => p.overrides[cat.key] ?? p.fallback(cat));
}

function runRandom() {
  applyPreset(() => Math.floor(Math.random() * 6));
}

function runReset() {
  applyPreset(() => 0);
}

document.getElementById('presetHi')?.addEventListener('click', () => runPreset('high'));
document.getElementById('presetLow')?.addEventListener('click', () => runPreset('low'));
document.getElementById('presetRand')?.addEventListener('click', runRandom);
document.getElementById('reset')?.addEventListener('click', runReset);

document.getElementById('exportCSV')?.addEventListener('click', exportCSV);
document.getElementById('exportJSON')?.addEventListener('click', exportJSON);





document.getElementById('presetRand').addEventListener('click', ()=>{
  CATEGORIES.forEach(cat=>{
    const val = Math.floor(Math.random() * 6);
    state[cat.key] = val;
    const sel = document.getElementById(cat.key);
    if (sel) {
      sel.value = val;
      updateSelectColor(sel, val);
    }
  });
  scheduleAll();
});

document.getElementById('reset').addEventListener('click', ()=>{
  CATEGORIES.forEach(cat=>{
    state[cat.key] = 0;
    const sel = document.getElementById(cat.key);
    if (sel) {
      sel.value = 0;
      updateSelectColor(sel, 0);
    }
  });
  scheduleAll();
});


updateOutputs();
scheduleUpdate();
</script>
  <footer class="site-footer fade">
    <div>
      <strong>Risk Scoring Tool</strong> &mdash; For educational and internal use only.<br>
      Data-driven risk prioritization for vulnerabilities. <br>
      <span style="color:#ec4899">Tip:</span> Use the controls above to simulate different risk scenarios.<br>
      <span style="color:#8b5cf6">Contact:</span> security-team@example.com
    </div>
  </footer>
  <div id="tooltip" role="tooltip" aria-hidden="true"></div>
</body>
</html>
